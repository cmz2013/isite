一、为什么要使用分布式锁

    为了保证一个方法在高并发情况下的同一时间只能被同一个线程执行，在传统单体应用单机部署的情况下，可以使用Java并发处理相关的
    API(如Lcok或synchronized)进行互斥控制。但是，随着业务发展的需要，原单体单机部署的系统被演化成分布式系统后，由于分布式
    系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，为了解决这个问题就需要一种跨JVM的互斥
    机制来控制共享资源的访问，这就是分布式锁要解决的问题

二、分布式锁具备哪些条件

    当我们在设计分布式锁的时候，我们应该考虑分布式锁至少要满足的一些条件，同时考虑如何高效的设计分布式锁，
    这里我认为以下几点是必须要考虑的。
    
    1、互斥
    在分布式高并发的条件下，我们最需要保证，同一时刻只能有一个线程获得锁，这是最基本的一点。
    
    2、防止死锁
    在分布式高并发的条件下，比如有个线程获得锁的同时，还没有来得及去释放锁，就因为系统故障或者其它原因使它无法执行释放锁的命令,
    导致其它线程都无法获得锁，造成死锁。所以分布式非常有必要设置锁的有效时间，确保系统出现故障后，在一定时间内能够主动去释放锁，
    避免造成死锁的情况。
    
    3、性能
    对于访问量大的共享资源，需要考虑减少锁等待的时间，避免导致大量线程阻塞。
    所以在锁的设计时，需要考虑两点。
    1）锁的颗粒度要尽量小。比如你要通过锁来减库存，那这个锁的名称你可以设置成是商品的ID,这个锁只对当前商品有效,锁的颗粒度小。
    2）锁的范围尽量要小。比如只要锁2行代码就可以解决问题的，那就不要去锁10行代码了。
    
    4、重入
    我们知道ReentrantLock是可重入锁，那它的特点就是：同一个线程可以重复拿到同一个资源的锁。重入锁非常有利于资源的高效利用。
    
三、分布式锁的实现方式
    
    1、数据库     操作数据库需要一定的开销，使用数据库的行级锁性能不靠谱
    2、Redis     redis主从异步同步期间，客户端可以正常访问master（redis数据同步是异步操作）
    3、Zookeeper ZK主从同步期间，客户端是不能访问服务的，同步完成才返回（zk数据同步是同步操作）

    就性能而言，redis很明显优于zookeeper；就分布式锁实现的健壮性或可靠性而言，zookeeper很明显优于redis
    
    redis实现分布式锁缺陷是在主从模式下，如果 master实例宕机的时候，可能导致多个客户端同时完成加锁：
    在主从模式下，客户端1对某个master节点写入了锁，此时会异步复制给对应的 slave节点。但是这个过程中一旦发生 master节点宕机，
    主备切换，slave节点从变为了 master节点。这时客户端2来尝试加锁的时候，在新的master节点上也能加锁，
    此时就会导致多个客户端对同一个分布式锁完成了加锁。这时系统在业务语义上一定会出现问题，导致各种脏数据的产生。
    
    如果既要高并发又要高可靠，redis分布式锁可以和数据库乐观锁组合使用。

四、基于Redis做分布式锁

    1、基于 REDIS 的 SETNX()、EXPIRE() 方法做分布式锁

    setnx 的含义就是 SET if Not Exists，其主要有两个参数 setnx(key, value)。该方法是原子的，如果 
    key 不存在，则设置当前 key 成功，返回 1；如果当前 key 已经存在，则设置当前 key 失败，返回 0。

    expire 设置过期时间，要注意的是 setnx 命令不能设置 key 的超时时间，只能通过 expire() 来对 key 设置。

    使用步骤：
    1、setnx(lockkey, 1) 如果返回 0，则说明占位失败；如果返回 1，则说明占位成功
    2、expire() 命令对 lockkey 设置超时时间，为的是避免死锁问题。
    3、执行完业务代码后，可以通过 delete 命令删除 key。
    
    这个方案还有一些可以完善的地方。比如，如果在第一步 setnx 执行成功后，在 expire() 命令执行成功前，发生了
    宕机的现象，那么就依然会出现死锁的问题，所以如果要对其进行完善的话，可以使用 redis 的 setnx()、get() 和 
    getset() 方法来实现分布式锁。
    
    2、基于 REDIS 的 SETNX()、GET()、GETSET()方法做分布式锁
    
    getset 这个命令主要有两个参数 getset(key，newValue)。该方法是原子的，对 key 设置 newValue 这个值，
    并且返回 key 原来的旧值。如果 key 原来是不存在的，返回null。
    
    使用步骤：
    1、setnx(lockkey, 当前时间+过期超时时间)，如果返回 1，则获取锁成功；如果返回 0 则没有获取到锁，转向低 2。
    2、get(lockkey) 获取值 oldExpireTime，并与当前的系统时间进行比较，如果小于当前系统时间， 则认为这个锁已经
    超时，可以允许别的请求重新获取，转向 3。
    3、计算 newExpireTime = 当前时间+过期超时时间，然后 getset(lockkey, newExpireTime) 会返回当前 
    lockkey 的值currentExpireTime。
    4、判断 currentExpireTime 与 oldExpireTime 是否相等，如果相等，说明当前 getset 设置成功，获取到了锁。
    如果不相等，说明这个锁又被别的请求获取走了，那么当前请求可以直接返回失败，或者继续重试。
    5、在获取到锁之后，当前线程可以开始自己的业务处理，当处理完毕后，比较自己的处理时间和对于锁设置的超时时间，如果
    小于锁设置的超时时间，则直接执行 delete 释放锁；如果大于锁设置的超时时间，则不需要再进行锁处理。
    
五、Redis分布式锁技术选型

    1、commons-web提供的分布式并发锁 API
    
        1）@Synchronized 支持接口申明式加锁，根据接口参数动态实例化key（接口参数支持数组、对象等复杂结构），自动释放锁
        2）Locksmith 支持语句块的编程式加锁，须要手动释放锁（@see SyncAspect#doBefore）
        3）支持短时间的忙时等待
    
    2、redisson 是 redis 官方的分布式锁组件。Redisson、Jedis、Lettuce 是三个不同的操作 Redis 的客户端，Jedis、
    Lettuce 的 API 更侧重对 Reids 数据库的 CRUD（增删改查），而 Redisson API 侧重于分布式开发，支持语句块的编程式
    加锁，须要手动释放锁。
